#!/bin/bash

LOG_PATH="/nef/docs"

#: terminal setup
bold=$(tput bold)
normal=$(tput sgr0)

red=$(tput setaf 1)
green=$(tput setaf 2)
lime=$(tput setaf 190)
reset=$(tput sgr0)

#: IN - Help

##
#   printHelp()
##
printHelp() {
    echo ""
    echo "${normal}$0 ${bold}--project ${normal}<project> ${bold}--output ${normal}<output>${reset}"
    echo ""
    echo "    ${lime}${bold}project${reset}${normal} path where playground's pages are. It will be use to render Jekyll site. ${reset}"
    echo "    ${lime}${bold}output${reset}${normal} path where to render the Jekyll site.${reset}"
    echo ""
}

#: - Compile

##
#   compile(String folder)
#   - Parameter `folder`: path to the project folder.
##
generateDocumentation() {
    local projectPath="$1"
    local sitePath="$2"

    makeStructure "$projectPath"
    buildMicrosite "$projectPath" "$sitePath"
}

buildMicrosite() {
    local projectPath="$1"
    local sitePath="$2"

    playgrounds "$projectPath"
    for playground in "${playgrounds[@]}"; do

        playgroundName=`echo "$playground" | rev | cut -d'/' -f -1 | cut -d'.' -f 2- | rev`
        playgroundPath="$projectPath/$playground"

        pagesInPlayground "$playgroundPath"
        for pagePath in "${pagesInPlayground[@]}"; do
            pageName=`echo "$pagePath" | rev | cut -d'/' -f -1 | cut -d'.' -f 2- | rev`
            echo "page: $pagePath ($pageName :: $playgroundName)"
        done
        echo "-----------------------"
    done
}

pagesInPlayground() {
    local playgroundPath="$1"         # parameter `playground`
    cd "$playgroundPath"

    pages=()

    dependencies="awk -F'page name=' '{print \$2}'"
    cleanUp="cut -d'/' -f -1"
    pagesNames=$(eval cat "contents.xcplayground | $dependencies | $cleanUp" 2>/dev/null)

    pagesNames=`echo "$pagesNames" | tr -s "\'" '\n' | tr -s '\n' '\t'` # ' -> \n -> \t
    IFS=$'\t' read -r -a pagesNames <<< "$pagesNames"                   # split by \t

    # A. in case `content.xcplayground` has not pages - get from folder `Pages`
    if [ "${#pagesNames}" -eq 0 ]; then
        pagesNames=`ls "Pages" | grep xcplaygroundpage`
        pagesNames=`echo "$pagesNames" | tr -s '\n' '\t'`
        IFS=$'\t' read -r -a pages <<< "$pagesNames"

    # B. get pages from `contents.xcplayground`
    else
      for page in "${pagesNames[@]}"; do
          pages+=("$page.xcplaygroundpage")
      done
    fi

    # build pages path
    pagesInPlayground=()
    for page in "${pages[@]}"; do
        pagesInPlayground+=("$playgroundPath/Pages/$page")
    done

    declare -p pagesInPlayground 1>/dev/null 2>/dev/null
}

playgrounds() {
    local path="$1"         # parameter `folder`

    workspace=$(workspaceForProjectPath "$1")
    content="$workspace/contents.xcworkspacedata"

    dependencies="awk -F'location = \"group:' '{print \$2}'"
    cleanUp="rev | cut -d'\"' -f 2- | rev | grep playground"
    playgrounds=$(eval cat "\"$content\" | $dependencies | $cleanUp" )

    playgrounds=`echo "$playgrounds" | tr -s '\n' '\t'` # '\n' -> '\t'
    IFS=$'\t' read -r -a playgrounds <<< "$playgrounds" # split by '\t'

    declare -p playgrounds 1>/dev/null 2>/dev/null
}

##
#   workspaceForProjectPath(String folder, String projectPath): String
#   - Parameter `folder`: path to the project folder.
#   - Parameter `projectPath`: path to the *.pbxproj file.
#   - Return `workspace` path
##
workspaceForProjectPath() {
    local path="$1"         # parameter `folder`
    local log="$1/$LOG_PATH/workspace.log"
    cd "$path"

    workspace=`ls | grep xcworkspace`
    numberOfWorkspaces=`echo "$workspace" | wc -l`
    workspacePath="$path/$workspace"

    if [ "$numberOfWorkspaces" -ne 1 ]; then
        echo "[!] error: found more than 1 workspace (total:$numberOfWorkspaces): '$workspace'" > "$log"
        exit -1
    elif [ -d "$workspacePath" ]; then
        echo $workspacePath
    else
        echo "[!] error: not found any workspace in root project '$path'" > "$log"
        exit -1
    fi
}

##
#   makeStructure(String project)
#   - Parameter `project`: path to the project folder.
##
makeStructure() {
  set +e
  local project="$1"  # parameter `project`

  cleanStructure "$project"
  mkdir -p "$project/$LOG_PATH"
}

cleanStructure() {
  set +e
  local project="$1"  # parameter `folder`

  rm -rf "$project/$LOG_PATH" 1>/dev/null 2>/dev/null
}


#: - MAIN
set -e

projectPath=""
sitePath=""

while [ "$1" != "" ]; do
    case $1 in
        -p | --project | project ) shift; projectPath=$1 ;;
        -o | --output | output )   shift; sitePath=$1 ;;
        -h | --help )              printHelp $@; exit 1 ;;
        * )                        printHelp $@; echo "${bold}[!] ${normal}${red}error:${reset} invalid argument: ${red}$1${reset}"; exit 1
    esac
    shift
done

if [ "$projectPath" == "" ]; then
    printHelp $@; echo "${bold}[!] ${normal}${red}error:${reset} 'project' argument is required"; exit 1
elif [ "$sitePath" == "" ]; then
    printHelp $@; echo "${bold}[!] ${normal}${red}error:${reset} 'output' argument is required"; exit 1
else
    generateDocumentation "$projectPath" "$sitePath"
fi
